

## element-ui

全局引入：

在 main.js 中写入以下内容：

```
import ElementUI from 'element-ui';
import 'element-ui/lib/theme-chalk/index.css';
Vue.use(ElementUI);
```

按需引入：

借助 [babel-plugin-component](https://github.com/QingWei-Li/babel-plugin-component)，我们可以只引入需要的组件，以达到减小项目体积的目的。

首先，安装 babel-plugin-component：

```
npm install babel-plugin-component -D
```

然后，将 .babelrc 修改为：

```
{
  "presets": [["es2015", { "modules": false }]],
  "plugins": [
    [
      "component",
      {
        "libraryName": "element-ui",
        "styleLibraryName": "theme-chalk"
      }
    ]
  ]
}
```

接下来，如果你只希望引入部分组件，比如 Button 和 Select，那么需要在 main.js 中写入以下内容：

```
import Vue from 'vue';
import { Button, Select } from 'element-ui';
import App from './App.vue';

Vue.component(Button.name, Button);
Vue.component(Select.name, Select);
/* 或写为
 * Vue.use(Button)
 * Vue.use(Select)
 */

new Vue({
  el: '#app',
  render: h => h(App)
});
```





## axios二次封装

在src中建立utils工具类包

创建request.js，并配置axios

自定义Axios实例

```
const instance = axios.create({
  baseURL: 'https://some-domain.com/api/',
  timeout: 1000,
  headers: {'X-Custom-Header': 'foobar'}
});
```

以下是可用的实例方法。指定的配置将与实例的配置合并```

```
axios#request(config)
axios#get(url[, config])
axios#delete(url[, config])
axios#head(url[, config])
axios#options(url[, config])
axios#post(url[, data[, config]])
axios#put(url[, data[, config]])
axios#patch(url[, data[, config]])
axios#getUri([config])
```

拦截器

在请求或响应被 then 或 catch 处理前拦截它们。`

```
// 添加请求拦截器
axios.interceptors.request.use(function (config) {
    // 在发送请求之前做些什么
    return config;
  }, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
  });

// 添加响应拦截器
axios.interceptors.response.use(function (response) {
    // 2xx 范围内的状态码都会触发该函数。
    // 对响应数据做点什么
    return response;
  }, function (error) {
    // 超出 2xx 范围的状态码都会触发该函数。
    // 对响应错误做点什么
    return Promise.reject(error);
  });
```

如果你稍后需要移除拦截器，可以这样：

```js
const myInterceptor = axios.interceptors.request.use(function () {/*...*/});
axios.interceptors.request.eject(myInterceptor);
```

可以给自定义的 axios 实例添加拦截器。

```
const instance = axios.create();
instance.interceptors.request.use(function () {/*...*/});
```



## mock.js

模拟后端返回数据

创建home.js写入随机生成数据的Api接口，

在mock.js中导入并调用该接口，返回接口随机生成的数据。

```
import Mock from 'mockjs'
import homeApi from './mockServeData/home'
//定义mock请求拦截
Mock.mock('/api/home/getData', 'get' , homeApi.getStatisticalData)
```



## echart

先安装引入echart

1、通过 echart.init方法初始化一个 echarts 实例

2、进行option配置，对于不同的图，配置内容不一样，具体见官网

3、将配置好的参数放入生成实例的setOption方法中

注意：装图标的容器需要定义好宽高



## 面包屑

目的：1、在面包屑位置添加名称 2、名称能实现路由转跳

由于点击面包屑的数据是由菜单、面包屑几处一起控制，所以相关数据应该放入store中

每当点击菜单时，面包屑中的数据tabslist:就应该传入相对应点击的菜单的数据，可以将这种传

方法A写进在store中。每当点击菜单的方法被调用时，就调用store中的这个传入方法A。

这样面包屑数据tabslist就能接收到点击的菜单对应的数据。

这store中tabslist数据解构出来，就可以在面包屑代码中v-for循环生成拥有的数据。





## 动态路由数据组装

对于不同的用户有不同的权限设置，即对于权限限制的用户不可以渲染所有路由。

这样的话，就需要按照用户权限进行动态路由渲染。

> ```
> addMenu(state, router){
>             //判断缓存是否有数据
>             if(!Cookie.get('menu')) return
>             const menu = JSON.parse(Cookie.get('menu'))
>             state.menu = menu
>             //组装动态路由数据
>             const menuArray = []
>             menu.forEach(item => {
>                 if(item.children) {
>                     item.children = item.children.map(item => {
>                         item.component = () => import(`../views/${item.urlh}`)
>                         return item
>                     })
>                     menuArray.push(...item.children)
>                 } 
>                 //没children
>                 else {
>                     item.component = () => import(`../views/${item.url}`)
>                     menuArray.push(item)
>                 }
>             })
>             console.log('arr', menuArray)
>             //路由动态添加
>             menuArray.forEach(item => {
>                 router.addRoute('Main', item)
>             })
>         }
> ```



* 清除动态创建的路由

> *// 清除动态添加的路由*
>
> ​        location.reload();
>
> ​        *this*.$router.push('/login')



## 前后端数据交互

### API V1接口说明

![image-20221128154630230](C:\Users\Samuel\AppData\Roaming\Typora\typora-user-images\image-20221128154630230.png)

#### 支持请求方法

![image-20221128154650881](C:\Users\Samuel\AppData\Roaming\Typora\typora-user-images\image-20221128154650881.png)

#### 通用返回状态说明

![image-20221128154713358](C:\Users\Samuel\AppData\Roaming\Typora\typora-user-images\image-20221128154713358.png)

### 登录

#### 登录验证接口

![image-20221128154851623](C:\Users\Samuel\AppData\Roaming\Typora\typora-user-images\image-20221128154851623.png)

![image-20221128154952834](C:\Users\Samuel\AppData\Roaming\Typora\typora-user-images\image-20221128154952834.png)



## Vue3重铸     
