# 面试刷刷刷

# JS、TS、ES6

## 1、传值和传址

基础数据类型是传值：存放在栈中（字符串、数字等）

复杂数据类型是传址：存放在堆中，指向栈（对象、函数等）



## 2、判断数据类型

1、typeof 主要用来判断基本数据类型

2、instanceof：数组+ instanceof + 构造原型 返回布尔值

3、object.prototype.toString.call()   会直接生产[object 输入数据的数据类型]



## 3、slice、split、splice

* splice：从数组中添加或删除元素，返回新的数组(⚠️：会对原数组进行更改，获取的是新的数组)

添加：splice(index，0，data1，data2，……);	index:插入的元素的起始位置；0：删除的个数为0；data1，data2：添加的元素；

删除：splice(index,0);	index:删除数组的起始位置；0：删除元素的个数；



* slice：用于截取数组，并返回截取到的新的数组，数组与字符串对象都使用(⚠️：对原数组不会改变)

语法：arr.slice(start,end)  左闭右开



* split：切割字符串，将字符串转化为字符串数组

根据a.split('')中传入的符号，对字符串进行分割并下放入数组。



## 4、数组遍历方法

1、foreach

![img](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303092145519.png)



2、map

**map即是 “映射”的意思 ，原数组被“映射”成对应新数组**
**map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。
map() 不会改变原始数组。
map() 不会对空数组进行检测。**
**map支持return**

![img](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303092147863.png)

map和forEach区别

1. forEach()和map()方法通常用于遍历Array元素
2. forEach：总是返回undefined；用来遍历数组中的每一项，不影响原数组，只是对数组每一项进行一次操作，并不能修改
3. map：返回一个包含已转换元素的新数组；支持return，相当于与原数组克隆了一份，把克隆的每项改变了，也不影响原数组



3、filter

filter用于对数组进行过滤。
filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。
filter() 不会对空数组进行检测；不会改变原始数组

`array.filter(function(currentValue,index,arr), thisValue)`



4、for..of

for-of循环不仅支持数组，还支持大多数类数组对象，例如DOM NodeList对象。但是for of也有一个致命伤，没有索引。对，这是优点也是缺点。遍历数组对象，直接就是item.属性(或者item[属性]),而不用像for循环那样arr[index].属性(arrindex)。

```
for(let item of arr){
    console.log(item);    //item指的的就是数组每一项的值。不是索引。
}
```



5、for...in

for in循环是用来遍历对象的。要知道JavaScript对象的所有属性都是字符串，不过属性对应的值可以是任意数据类型。（注意：遍历时不仅能读取对象自身上面的成员属性，也能遍历出对象的原型属性）

```
let obj = {a:1, b:2, c:3};
for (let prop in obj) {    //prop指对象的属性名
console.log(prop, obj[prop]);
}
// 输出:
// a,1
// b,2
// c,3
```



6、find方法

- **遍历数组，找到第一个符合条件的项，并返回该项；不会继续遍历数组；否则返回undefined**
- **不会改变数组**

`[1,4,-5,10].find((n) => n < 0 ) `000



7、findindex方法

- **遍历数组找到第一个符合条件的项，并返回该项的索引值；不会继续遍历数组；否则返回-1。**
- **不会改变数组**

同上，只不过返回的是索引



9、some方法

**1）如果`有一个元素满足条件`，则表达式返回`true`，剩余的元素不会再执行检测。**
**2）如果没有满足条件的元素，则返回false。**
**3）返回值是布尔值**

注：

**1) some() 不会对空数组进行检测。**
**2) some() 不会改变原始数组。**



10、every方法

**1）如果数组中有一个元素不满足，则整个表达式返回false；且剩余的元素不会再进行检测**
**2）如果`所有元素都满足条件`，则返回`true`。**
**3）返回值是布尔值**

 

10、reduce方法

![image-20230325163135999](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303251631095.png)

total为上次调用返回的值或者初始值，每循环一次，结果都会迭代掉total，变成新的total。

**1）接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。**
**2）第二个参数作为第一次调用的a的值**

## 5、深拷贝和浅拷贝

浅拷贝：复杂数据类型的地址

深拷贝：完全赋值一份数据一样的非同一地址的数据



## 6、this

this指的是当前代码执行的上下文

顶层全局作用域为window

声明的全局变量挂在在window上

普通函数的this是执行时绑定，箭头函数是声明时绑定this（声明时的作用域的this）；比如在windows声明了对象A，对象A中不管嵌套了多少层，再打印this，这个this都是指向声明A时作用域下的this，即window



## 7、改变this的方法

1、 call 改名this指向并立即执行函数，参数逗号分隔

2、apply 改名this指向并立即执行函数，参数以数组形式写

3、bind 语法和call相同，但改变完不会立即执行，需要在后面再加个小括号才执行



## 8、new的过程

`let obj = new Object()`

1. 首先创建了一个新的`空对象`
2. `设置原型`，将对象的原型设置为函数的`prototype`对象。（继承原型链）
3. 让函数的`this`指向这个对象，执行构造函数的代码（构造函数继承）
4. 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

如果没有return或者return的是简单数据类型，则忽略；直接进行return this

如果return的是复杂数据类型，则返回的就是当前return的值



## 9、异步解决方案

1、callback回调函数（将回调函数以传参的方式先传给函数，等到时机成熟，函数再去调用回调函数）

> ```
> function get(callback){
>   setTimeout(() => {
>     callback("你好")
>   }, 1000);
> }
> 
> get((res) => {
>   console.log(res)
> })
> ```



2、promise函数

promise函数有三种状态：pending => 转为另外两种状态resolve/reject，resolve和reject只有第一次执行有效

> ```
> function p1(param) {
>   return new Promise((resolve, reject) => {
>     resolve("成功")
>     reject("失败")
>   })
> }
> 
> p1().then(res => {
>   console.log(res)
> }).catch(err => {
>   console.log(err)
> })
> ```

promise.all：多个异步任务执行完进行操作

> ```
> //参数为promise对象组成的数组，then必须全resolve
> promise.all([p_1(),p_2(),p_3()]).then(res => {
> 	...
> }).catch(err => {
> 	//返回最近的一个错误
> 	...
> })
> ```





3、asycn_await

async可以单独使用，且返回的是promise对象

await（后跟异步或promise）必须配合async使用

> ```
> function f3(params) {
>   return new Promise((resolve, reject) => {
>     setTimeout(() => {
>       resolve("成！")
>     }, 1000)
>   })
> }
> 
> async function f3_await() {
>   let res = await f3()
>   console.log(res)
> }
> //不用async的话，调用f3_await也只是在pending状态
> ```



## 10、原型链prototpye/\__proto__

prototype：只有函数对象才有，即（构造）函数原型对象，会返回一个对象 

\__proto__：所有对象都有此属性，总是指向该对象对应的构造函数的原型对象

constructor：\__proto__下面的constructor指向构造函数自己（用于判断对象的原型是否为某个对象）

```
对象.__proto__ === 对象的构造函数.prototype  // true
对象.__proto__.__proto__ === 对象的构造函数.prototype.__proto__  // true
对象.__proto__.constructor==对象的构造函数
```



* 原型链终点：Object.prototype

* 对象访问属性时，先在自身属性查找，找不到再去\__proto__的原型链上查找，直到找不到为止会返回undefined

![image-20230311134532149](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303111345497.png)

![img](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303251724816.png)



## 11、闭包

闭包是指有权访问另一个函数作用域中的变量的函数



如果一个函数访问了此函数的父级及父级以上的作用域变量，那么这个函数就是一个闭包。

闭包：函数套函数，并把内部函数return，内部函数可以访问外部函数的变量，一级级向上找；是内部函数访问父函数的变量的结果（内部函数引用外部函数的局部变量，延长外部函数的变量生命周期）

特点：

 让外部访问函数内部变量成为可能；

 局部变量会常驻在内存中；

 可以避免使用全局变量，防止全局变量污染；

 会造成内存泄漏（有一块内存空间被长期占用，而不被释放）

作用：封装变量，收敛权限

优点：不会造成全局变量污染

内存：垃圾回收机制：当一个变量在作用域内部不再被使用，会被内存释放（使用闭包不会被垃圾回收机制回收，可能造成内存泄漏）

> ```
>   function fn() {
>      var num=3;
>      return function(){
>         var n=0;
>         console.log(++n);
>         console.log(++num);
>      }
>   }
>   var fn1=fn();
>   fn1();//n=1;num=4
>   fn1();//n=1;num=5
> ```

​		一般情况下，在函数fn执行完后，就应该连同它里面的变量一同被销毁，但是在这个例子中，匿名函数作为fn的返回值被赋值给了fn1，这时候相当于fn1=function(){var n = 0 ... }，并且匿名函数内部引用着fn里的变量num，所以变量num无法被销毁，而变量n是每次被调用时新创建的，所以每次fn1执行完后它就把属于自己的变量连同自己一起销毁，于是乎最后就剩下孤零零的num，于是这里就产生了内存消耗的问题。



Javascript语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。



嵌套函数的作用？

嵌套函数只是因为要定义局部变量，不嵌套函数的话就是全局变量了。



return的作用？

return只是为了可以让外界访问return的函数，如果将return f1 改为window.f1也是一样的。

## 12、防抖和节流

防抖：用户一直触发某个函数，触发时间间隔如果小于设定的时间间隔，则只执行一次

节流：在设定之间间隔内执行一次

区别：防抖和节流本质是不一样的。防抖是将多次执行变为最后一次执行（停下后的最后一次才执行），节流是将多次执行变成每隔一段事件执行（会执行，且按照时间间隔执行）

> ```
> //防抖，如果有继续点击，就清除定时器
> let a = document.createElement("input")
> a.type = "button"
> a.value = "点一下"
> document.body.appendChild(a)
> 
> function debounce(fn ,delay){
>   let time = null
>   return function(){
>     clearTimeout(time)
>     time = setTimeout(()=>{
>       fn()
>     },delay)
>   }
> }
> 
> function btn1() {
>   console.log('点一下')
> }
> 
> a.onclick = debounce(btn1, 500)
> ```



> ```
> //节流
> let a = document.createElement("input")
> a.type = "button"
> a.value = "点一下"
> document.body.appendChild(a)
> function debounce(fn ,delay){
>   let lastTime = 0
>   return function(){
>     let nowTime = new Date().getTime()
>     if(nowTime - lastTime > delay){
>       btn1()
>       lastTime = nowTime
>     }
>   }
> }
> 
> function btn1() {
>   console.log('点一下')
> }
> 
> a.onclick = debounce(btn1, 1000)
> ```







## 13、nextTick

定义：下一次Dom更新结束后的回调函数，（最近一次数据渲染或更新后执行）

nextTick 就是设置一个回调，用于异步执行。就是把你设置的回调放在 setTimeout 中执行，这样就算异步了，等待当时同步代码执行完毕再执行。



## 14、JS运行机制

JS 执⾏是单线程的， 它是基于事件循环的。 事件循环⼤致分为以下⼏个步骤：
（1） 所有同步任务都在主线程上执⾏， 形成⼀个执⾏栈（execution context stack） 。
（2） 主线程之外， 还存在⼀个"任务队列"（task queue） 。 只要异步任务有了运⾏结果， 就在"任务队列"之中放置⼀个事件。
（3） ⼀旦"执⾏栈"中的所有同步任务执⾏完毕， 系统就会读取"任务队列"， 看看⾥⾯有哪些事件。 那些对应的异步任务， 于是结束等待状态， 进⼊执⾏栈， 开始执⾏。
（4） 主线程不断重复上⾯的第三步。



## 15、块级作用域

​	JS 中，有三种作用域，分别为：全局作用域、函数作用域、块级作用域。
当执行一个项目或一个文件时，会先生成全局作用域；在执行每一个函数时，会生成对应的函数作用域；这两个作用域都是 JS 设计之初就有的，而块级作用域则是 ES6 才实现的。

正常情况下，JS 引擎在编译代码阶段会生成全局执行上下文和函数执行上下文。这其中，每个上下文又分为了两个部分：变量环境和词法环境。

![image-20230313225724386](C:\Users\Samuel\AppData\Roaming\Typora\typora-user-images\image-20230313225724386.png)

![image-20230313225731329](C:\Users\Samuel\AppData\Roaming\Typora\typora-user-images\image-20230313225731329.png)

1. 使用 var 关键字声明的变量、及函数声明，会被放入变量环境中
2. 使用 let 及 const 关键字声明的变量和常量会被放入词法环境中
3. 词法环境内部也类似于一个栈结构，每一个块结构(即有一对大括号，如条件句、循环等)内的变量和常量会单独保存(使用 var 关键字声明的不会)。
4. 所以，如上面的例子，函数 foo 的词法环境里，有两个区域。下面的区域保存了函数体内使用 let 声明的变量，上面的区域保存了 if 语句中使用 let 声明的变量。所以即使它们都叫做 b，但却是两个不同的变量。

如此一来，ES6 就通过执行上下文中的词法环境实现了块级作用域。

https://www.jianshu.com/p/cdf85625450a

## 16、数据类型

包括值类型(基本对象类型)和引用类型(复杂对象类型)

**基本类型(值类型)：** Number(数字),String(字符串),Boolean(布尔),Symbol(符号),null(空),undefined(未定义)在内存中占据固定大小，保存在栈内存中

**引用类型(复杂数据类型)：** Object(对象)、Function(函数)。其他还有Array(数组)、Date(日期)、RegExp(正则表达式)、特殊的基本包装类型(String、Number、Boolean) 以及单体内置对象(Global、Math)等 引用类型的值是对象 保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址。





## 17、var、let、const

const 基本类型不可修改，对象类型可以修改（const不可以修改栈里的地址，但可以修改堆里的数据）

let的暂时性死区（先定义再使用，拒绝变量提升）

区别：

1、var定义的变量，`没有块的概念，可以跨块访问`, 不能跨函数访问。
 let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。
 const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，且不能修改。

2、var可以`先使用，后声明`，因为存在变量提升；let必须先声明后使用。

3、var是允许在相同作用域内`重复声明同一个变量`的，而let与const不允许这一现象。

4、在全局上下文中，基于let声明的全局变量和全局对象GO（window）没有任何关系 ;
 var声明的变量会和GO有映射关系；

5、`会产生暂时性死区`： 检测未申明变量时，不会报错，而是返回undefined



## 18、JS垃圾回收机制

​		项目中，如果存在大量不被释放的内存（堆/栈/上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存。

原理：浏览器的`Javascript`具有自动垃圾回收机制(`GC:Garbage Collecation`)，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。

**优化手段**：内存优化 ; 手动释放：取消内存的占用即可。

（1）堆内存：fn = null 【null：空指针对象】

（2）栈内存：把上下文中，被外部占用的堆的占用取消即可。

**内存泄漏**：在 JS 中，常见的内存泄露主要有 4 种,全局变量、闭包、DOM 元素的引用、定时器



## 19、EventLoop 事件循环

​		JS是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步任务队列，异步任务队列又分为**宏任务**队列和**微任务**队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。微任务队列的代表就是，Promise.then，MutationObserver，宏任务的话就是setImmediate setTimeout setInterval



* 浏览器中的事件环(event loop)

事件环的运行机制是，先会执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后在取宏任务清微任务这样不停的循环。

事件循环可以简单的描述为以下四个步骤:

1. 函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空；
2. 此期间WebAPIs完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）
3. 执行栈为空时，Event Loop把微任务队列执行清空；
4. 微任务队列清空后，进入宏任务队列，取队列的第一项任务放入Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。

**任务源(task):**

- `宏任务(macrotask)`（不需要立即连贯执行）：
   宿主环境提供的，比如浏览器
   ajax、setTimeout、setInterval、setTmmediate(只兼容ie)、script、requestAnimationFrame、messageChannel、UI渲染、一些浏览器api
- `微任务(microtask)`（需要立即连贯执行）：
   语言本身提供的，比如promise.then
   then、queueMicrotask(基于then)、mutationObserver(浏览器提供)、messageChannel 、mutationObersve

![image-20230325140635272](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303251406374.png)



* Node环境的事件环

![2020120317343116.png](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303222258109.webp)

- `timers`: 计时器，执行setTimeout和setInterval的回调
- `pending callbacks`: 执行延迟到下一个循环迭代的 I/O 回调
- `idle, prepare`: 队列的移动，仅系统内部使用
- `poll轮询`: 检索新的 I/O 事件;执行与 I/O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。
- `check`: 执行`setImmediate`回调，setImmediate在这里执行
- `close callbacks`: 执行`close`事件的`callback`，一些关闭的回调函数，如：socket.on('close', ...)



## 20、setTimeout、Promise、Async/Await 的区别

1、setTimeout

settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行。

2、Promise

Promise本身是**同步的立即执行函数**， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行。

3、async/await

async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。

async/await通过同步实现异步方法

Async/Await就是一个**自执行**的generate函数。利用generate函数的特性把异步的代码写成“同步”的形式,第一个请求的返回值作为后面一个请求的参数,其中每一个参数都是一个promise对象.

如果await等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。

## 21、图片懒加载

好处：减少HTTP请求，加快网页响应速度，减少服务器压力，增加用户浏览体验

原理：

1、监控滚动条滚动

2、获取总可视内容高度（可见视口高度+滚动条滚动高度）

3、获取所有图片

4、遍历步骤3（或这说：遍历伪数组）

5、在步骤4中判断，图片.offsetTop <= 步骤2 true-修改src属性为data-src、false-不管

6、 节流防抖优化



## 22、DOM事件流

捕获阶段：事件从Document节点自上而下向目标节点传播的阶段；
目标阶段：真正的目标节点正在处理事件的阶段；
冒泡阶段：事件从目标节点自下而上向Document节点传播的阶段。

![img](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303241106254.png)





## 23、事件委托

概念：事件委托也称为事件代理。就是利用事件冒泡，把子元素的事件都绑定到父元素上。如果子元素阻止了事件冒泡，那么委托就无法实现。

事件委托的好处：

- 利用冒泡的原理，将事件加到父级身上，这样只在内存中开辟一块空间，既节省资源又减少DOM操作，提高性能

- 可以为动态添加的元素绑定事件



## 24、 Object构造函数上语法

重要

Object.defineProperty() vue双向绑定原理
Object.keys() 获取对象的所有键 返回数组
Object.values() 获取对象的所有值 返回数据
Object.create() 创建对象（特色 基于指定原型造对象 场景1：new原理优化，场景2：vue ）
Object.assign() 合并对象
Object.prototype.constructor 所属构造函数
Object.prototype.toString() 转字符串



## 25、Dom操作

* 获取：
  getElementById() 通过id获取dom节点
  getElementByTagName() 通过标签名获取dom节点
  getElementByClassName() 通过类名获取dom节点
  querySelector() 通过css选择器获取第一个符合的dom节点
  querySelectorAll() 通过css选择器获取所有符合的dom节点，结果是一个伪数组

* 操作：
  el.getAttribute() 获取el的属性
  el.setAttribute() 设置el的属性
  el.removeAttribute() 删除el的属性
  元素节点上有一个dataset，里面包含了所有的H5自定义属性
  el.dataset.属性名 获取H5自定义属性值
  el.dataset.属性名 = “值” 设值
  delete el.dataset.属性名 删除
  el.innerHTML 元素的可读写属性，里面的HTML代码可以被解析
  el.innerText 元素的文本内容，里面的HTML代码打印出来是字符串
  el.value 用于操作表单元素的内容





## 26、Map对象

Map 对象存有键值对，其中的键可以是任何数据类型。
Map 对象记得键的原始插入顺序。
Map 对象具有表示映射大小的属性。

* 基本的 Map() 方法：
  new Map() 创建新的 Map 对象。
  set() 为 Map 对象中的键设置值。
  get() 获取 Map 对象中键的值。
  entries() 返回 Map 对象中键/值对的数组。
  keys() 返回 Map 对象中键的数组。
  values() 返回 Map 对象中值的数组。
  Map.clear() 从 Map 中移除所有元素



map添加对象的方法：

> ```
> 1、
> var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
> 
> 2、
> var m = new Map()
> m.set('Adam', 67); // 添加新的key-value
> m.set('Bob', 59);
> m.has('Adam'); // 是否存在key 'Adam': true
> m.get('Adam'); // 67
> ```

## 27、进程和线程的区别

什么是进程？进程是一个正在执行的程序的实例。

什么是线程？线程是进程的一个执行路径，同一个进程中的线程共享进程的资源

- **本质区别**：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。

- **影响关系**：一个进程崩溃后，在保护模式下其他进程不会被影响，但是一个线程崩溃可能导致整个进程被操作系统杀掉，所以多进程要比多线程健壮。



并行和并发：

![image-20230530223209943](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202305302232122.png)



## 28、阻塞问题

js阻塞问题是指当浏览器在解析文档或者渲染页面时，遇见了js代码，需要渲染引擎中断，而运行js引擎，从而阻塞浏览器原本的工作状态。

解决方法：
1、将script标签放在body闭合时的上方；
2、利用dom动态创建script标签；
3、将script标签放在头部，但是要加上async或者defer属性

* async、defer区别

共同点：可以让浏览器进行异步加载js代码，而不会出现js阻塞的情况
区别：
	async：当js代码加载会之后会异步执行js代码；
	defer：当js代码加载完之后回等到dom解析完之后，在DocumentContentLoaded之前执行js代码，在一定程度上可以保证js代码加载的顺序。



# 计算机网络

## 1、三次握手、四次挥手

![](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303202145313.png)

第一次握手：`建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认`；SYN：同步序列编号（Synchronize Sequence Numbers）。

第二次握手：`服务器收到syn包并确认客户的SYN`（ack=j+1），`同时也发送一个自己的SYN包`（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：`客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1）`，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。



**SYN：用于建立连接。** **ACK：用于确定收到了请求。** **seq：发送自己的数据。** **FIN表示关闭连接**

**ack：发送接收到的对方的数据**

![img](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303202148573.png)

![img](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303202200254.png)

四次挥手原理：

第1次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态；

第2次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态；

第3次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态；

第4次挥手：客户端收到FIN后，客户端t进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，服务端进入CLOSED状态，完成四次挥手。

其中：FIN标志位数置1，表示断开TCP连接。



为什么不能两次握手呢？

如果只有两次握手，意味着服务端没有接收到客户端的应答，客户端可以向服务端发送消息，而服务端却未知客户端是否准备好而不能向客户端发送消息，违背了TCP连接全双工的定义。（为了防止已失效的连接请求报文段图如又传送到了服务器，导致服务器永久等待客户端发送新的包）



为什么不能三次挥手？

全双工的TCP连接，双方都在工作。客户端结束工作后，不能保证服务端也结束了工作，所以需要服务端的应答，等服务端消息发完后，再请求释放链接



## 2、TCP和UDP

1、TCP是面向`连接`的，而UDP是面向报文的。

2、TCP仅支持`单播传输`，UDP 提供了单播，多播，广播的功能。

3、TCP的三次握手保证了连接的`可靠性`; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。

4、UDP的`头部开销`比TCP的更小，数据`传输速率更高`，`实时性更好`。





## 3、HTTP跨域请求解决方案

* 原理：

**跨域**，是指浏览器不能执行其他网站的脚本。它是由浏览器的`同源策略`造成的。
**同源策略**,是浏览器对 JavaScript 实施的安全限制，只要`协议、域名、端口`有任何一个不同，都被当作是不同的域。
**跨域原理**，即是通过各种方式，`避开浏览器的安全限制`。



* 解决方法 

**1、JSONP**

方法：当需要跨域请求时，不使用AJAX，转而生成一个script元素去请求服务器，由于浏览器并不阻止script元素的请求，这样请求可以到达服务器。服务器拿到请求后，响应一段JS代码，这段代码实际上是一个函数调用，调用的是服务端预先生成好的函数，并把浏览器需要的数据作为参数传递到函数中，从而间接的把数据传递给客户端。

步骤：

1. 去创建一个script标签
2. script的src属性设置接口地址
3. 接口参数，必须要带一个自定义函数名，要不然后台无法返回数据
4. 通过定义函数名去接受返回的数据

缺点：JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。



**2、CORS** 

CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求



**3、Proxy代理**

代理就是，比如你通过域A访问域B，那么在域A中架设一台代理服务器，把请求转发到域B，然后浏览器访问域A即可，这其中不涉及到跨域访问了。

前端后端分离开发时经常会用到这个特性，在本地架设一个代理服务器，以免浏览器无法跨域访问api。

例如：有一个天气预报页面[http://www.a.com](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.a.com)，需要向[http://www.weather.com](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.weather.com)接口获取天气数据，但是这个接口不支持JSONP和CORS跨域，那么可以这样做：

1. 搭建服务器，创建一个获取天气的接口[http://www.b.com](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.b.com)
2. 设置接口[http://www.b.com](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.b.com)的响应头`Access-Control-Allow-Origin:http://www.a.com`
3. 页面[http://www.a.com](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.a.com)向[http://www.b.com](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.b.com)发请求
4. [http://www.b.com](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.b.com)收到请求后，向[http://www.weather.com](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.weather.com)获取天气数据，然后将天气数据返回给[http://www.a.com](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.a.com)



## 4、输入URL到加载页面的过程

1、URL解析：判断浏览器输入的是搜索内容还是URL；

2、查找缓存：如果能找到缓存则直接返回页面，如果没有缓存则需要发送网络请求页面；

3、DNS域名解析；

4、三次握手建立TCP连接；

5、发起HTTP请求；

6、服务器响应并返回结果；

7、通过四次握手释放TCP连接；

8、浏览器渲染；

9、js引擎解析





## 5、常见状态码

1xx（临时响应）
表示临时响应并需要请求者继续执行操作的状态码。

| 100（继续）     | 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 |
| --------------- | ------------------------------------------------------------ |
| 101（切换协议） | 请求者已要求服务器切换协议，服务器已确认并准备切换。         |

2xx （成功）

表示成功处理了请求的状态码。

| 200（成功）       | 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。 |
| ----------------- | ------------------------------------------------------------ |
| 201（已创建）     | 请求成功并且服务器创建了新的资源。                           |
| 202（已接受）     | 服务器已接受请求，但尚未处理。                               |
| 203（非授权信息） | 服务器已成功处理了请求，但返回的信息可能来自另一来源。       |
| 204（无内容）     | 服务器成功处理了请求，但没有返回任何内容。                   |
| 205（重置内容）   | 服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。 |
| 206（部分内容）   | 服务器成功处理了部分 GET 请求。                              |

3xx （[重定向](https://so.csdn.net/so/search?q=重定向&spm=1001.2101.3001.7020)）
要完成请求，需要进一步操作。通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的[网络抓取](http://www.google.cn/support/webmasters/bin/answer.py?answer=35156)页列出了由于重定向错误导致 Googlebot 无法抓取的网址。

| 300（多种选择）     | 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 |
| ------------------- | ------------------------------------------------------------ |
| 301（永久移动）     | 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。 |
| 302（临时移动）     | 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 |
| 303（查看其他位置） | 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。 |
| 304（未修改）       | 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。 |
| 305（使用代理）     | 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 |
| 307（临时重定向）   | 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 <a href=answer.py?answer=>301</a> 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 |

4xx（请求错误）
这些状态码表示请求可能出错，妨碍了服务器的处理。

| 400（错误求）             | 服务器不理解请求的语法。                                     |
| ------------------------- | ------------------------------------------------------------ |
| 401（未授权）             | 请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。 |
| 403（禁止）               | 服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。 |
| 404（未找到）             | 服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具[“诊断”标签的 robots.txt 页](http://www.google.cn/support/webmasters/bin/answer.py?answer=35237)上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。如果对于 Googlebot 抓取的网址看到此状态码（在”诊断”标签的 [HTTP 错误页面](http://www.google.cn/support/webmasters/bin/answer.py?answer=35122)上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。 |
| 405（方法禁用）           | 禁用请求中指定的方法。                                       |
| 406（不接受）             | 无法使用请求的内容特性响应请求的网页。                       |
| 407（需要代理授权）       | 此状态码与 <a href=answer.py?answer=35128>401（未授权）</a>类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。 |
| 408（请求超时）           | 服务器等候请求时发生超时。                                   |
| 409（冲突）               | 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。 |
| 410（已删除）             | 如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。 |
| 411（需要有效长度）       | 服务器不接受不含有效内容长度标头字段的请求。                 |
| 412（未满足前提条件）     | 服务器未满足请求者在请求中设置的其中一个前提条件。           |
| 413（请求实体过大）       | 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 |
| 414（请求的 URI 过长）    | 请求的 URI（通常为网址）过长，服务器无法处理。               |
| 415（不支持的媒体类型）   | 请求的格式不受请求页面的支持。                               |
| 416（请求范围不符合要求） | 如果页面无法提供请求的范围，则服务器会返回此状态码。         |
| 417（未满足期望值）       | 服务器未满足”期望”请求标头字段的要求。                       |

5xx（服务器错误）
这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。

| 500（服务器内部错误）    | 服务器遇到错误，无法完成请求。                               |
| ------------------------ | ------------------------------------------------------------ |
| 501（尚未实施）          | 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 |
| 502（错误网关）          | 服务器作为网关或代理，从上游服务器收到无效响应。             |
| 503（服务不可用）        | 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 |
| 504（网关超时）          | 服务器作为网关或代理，但是没有及时从上游服务器收到请求。     |
| 505（HTTP 版本不受支持） | 服务器不支持请求中所用的 HTTP 协议版本。                     |



## 6、get和post有什么区别

GET在浏览器回退时是无害的，而POST会再次提交请求。

GET产生的URL地址可以被Bookmark，而POST不可以。

GET请求会被浏览器主动cache，而POST不会，除非手动设置。

GET请求只能进行url编码，而POST支持多种编码方式。

GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

GET请求在URL中传送的参数是有长度限制的，而POST么有。

对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

GET参数通过URL传递，POST放在Request body中。



## 7、http 0.9/1/1.1/2

* **http 0.9**
  * 请求端只支持get请求
  * 响应端只返回HTML文本数据

**缺点：**1、请求方式唯一，返回格式唯一  2、TCP连接无法复用



* **http/1.0**

  HTTP/1.0 诞生于1996 年，它在 HTTP/0.9 的基础上，增加了 HTTP 头部字段，极大扩展了 HTTP 的使用场景。这个版本的 HTTP 不仅可以传输文字，还能传输图像、视频、二进制文件，为互联网的迅速发展奠定了坚实的基础。

  特点如下：

  * 请求端增加 HTTP 协议版本，响应端增加状态码。

  * 请求方法增加 POST、HEAD。

  * 请求端和响应端增加头部字段。

  * - Content-Type 让响应数据不只限于超文本。
    - Expires、Last-Modified 缓存头。
    - Authorization 身份认证。
    - Connection: keep-alive 支持长连接，但非标准。

  * 

![image-20230419113040588](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202304191130688.png)

可以看到，HTTP/1.0 扩展了请求方法和响应状态码，并且支持定义 HTTP 头部字段，通过 `Content-Type` 头，我们就能传输任何格式的数据了。同时可以看出，HTTP/1.0 仍然是一个请求对应一个 TCP 连接，不能形成复用。

**缺点：**1、TCP 连接无法复用。 2、HTTP 队头阻塞，一个 HTTP 请求响应结束之后，才能发起下一个 HTTP 请求。3、一台服务器只能提供一个 HTTP 服务。

* **http/1.1**（一次一份）
  * 持久连接。
  
  * - HTTP/1.1 默认开启持久连接，在 TCP 连接建立后不立即关闭，让多个 HTTP 请求得以复用。
  
  * 管线化技术。
  
  * - HTTP/1.1 中，多个 HTTP 请求不用排队发送，可以批量发送，这就解决了 HTTP 队头阻塞问题。但批量发送的 HTTP 请求，必须按照发送的顺序返回响应（比如同时请求了 1 2 3，返回就得按 1 2 3的顺序返回），相当于问题解决了一半，仍然不是最佳体验。
  
  * 支持响应分块。
  
  * - HTTP/1.1 实现了流式渲染，响应端可以不用一次返回所有数据，可以将数据拆分成多个模块，产生一块数据，就发送一块数据，这样客户端就可以同步对数据进行处理，减少响应延迟，降低白屏时间。
    - Bigpipe 的实现就是基于这个特性，具体是通过定义 `Transfer-Encoding` 头来实现的。
  
  * 增加 Host 头。
  
  * - HTTP/1.1 实现了虚拟主机技术，将一台服务器分成若干个主机，这样就可以在一台服务器上部署多个网站了。
    - 通过配置 Host 的域名和端口号，即可支持多个 HTTP 服务： `Host: <domain>:<port>`
  
  * 其他扩展。
  
  * - 增加 Cache-Control、E-Tag 缓存头。
    - 增加 PUT、PATCH、HEAD、 OPTIONS、DELETE 请求方法。

![image-20230419115037639](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202304191150718.png)

可以看到，HTTP/1.1 可以并行发起多个请求，并且也能复用同一个 TCP 连接，传输效率得到了提升。但响应端只能按照发送的顺序进行返回，为此很多浏览器会为每个域名至多打开 6 个连接，用增加队列的方式减少 HTTP 队头阻塞。



**缺点：**HTTP 队头阻塞（http请求过程中，有一次的请求出现了错误）没有彻底解决，响应端必须按照 HTTP 的发送顺序进行返回，如果排序靠前的响应特别耗时，则会阻塞排序靠后的所有响应。



* **http/2.0**

HTTP/2 将一个 HTTP 请求报文划分为 3 个部分：

- 帧：一段二进制数据，是 HTTP/2 传输的最小单位。
- 消息：一个请求或响应对应的一个或多个帧。
- 数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。

HTTP/2 核心特点如下：

- 请求优先级

- - 多个 HTTP 请求同时发送时，会产生多个数据流，数据流中有一个优先级的标识，服务器端可以根据这个标识来决定响应的优先顺序。

- **多路复用**

- - TCP 传输时，不用按照 HTTP 的发送顺序进行响应，可以交错发送，接收端根据帧首部的标识符，就能找到对应的流，进而重新组合得到最终数据。

- 服务器端推送

- - HTTP/2 允许服务器未经请求，主动向客户端发送资源，并缓存到客户端中，以避免二次请求。
  - HTTP/1.1 中请求一个页面时，浏览器会先发送一个 HTTP 请求，然后得到响应的 HTML 内容并开始解析，如果发现有 `<script src="xxxx.js">` 标签，则会再次发起 HTTP 请求获取对应的 JS 内容。而 HTTP/2 可以在返回 HTML 的同时，将需要用到的 JS、CSS 等内容一并返回给客户端，当浏览器解析到对应标签时，也就不需要再次发起请求了。

- 头部压缩

- - HTTP/1.1 的头部字段包含大量信息，而且每次请求都得带上，占用了大量的字节。
  - HTTP/2.0 中通信双方各自缓存一份头部字段表，如：把 `Content-Type:text/html` 存入索引表中，后续如果要用到这个头，只需要发送对应的索引号就可以了。

- 

![image-20230419115224589](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202304191152662.png)

## 8、https

在http的基础上使用了TLS/SSL进行加密

* 对称加密

使用相同的加密规则对内容进行加密，但容易被破解



* 非对称加密

![image-20230525225033863](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202305252250022.png)







## 9、token

token存储在redis，前端访问接口或者页面时先让路由判断本地cookie有没有存储token，如果没有就跳转到登录页面去后端根据你前端传递的用户json数据去生成token然后存储在redis当中并且设置你的token失效时间与你的cookie以及redis失效时间保持一致，前端拿到后端返回的token就添加在cookie中，后续前端所有的页面访问接口的时候都在ajax当中把你cookie附带在请求头里，后端也需要通过路由设置全局拦截器来拦截以及放行需要请求头中附带token的接口



* token存放位置

**1、cookies**

自动发送，但不能实现跨域；

安全性方面：将token存放在cookie中可以指定 httponly，来防止被Javascript读取，避免xss攻击，也可以指定secure，来保证token只在HTTPS下传输。缺点是容易受到CSRF攻击。

**2、localStorage**

将token存储在localStorage中，每次调用接口的时候放在HTTP请求头的Authorization字段里。且同时适用于浏览器环境he

此字段需要由 JS 代码来写入，请求想要带上 `Authorization` 字段则需要用 JS 代码来给请求方法添加全局拦截器，因此它天生具备防止 CSRF 的功能；缺点：存在XSS攻击盗取token问题



## 10、JWT

​		jwt一般包含三个部分header、payload和signature，header包括两个字段说明token的类型和采用的签名算法，payload包含用户的一些身份权限信息但不包含敏感信息，signature是服务端的签名由前两个部分采用base64编码后再经过签名算法加密生成，签名算法的私钥由服务器保管。

​		服务端生成jwt后返回给客户端。客户端下次调用api的请求头中放入token用于鉴权，服务端会通过jwt的前两个部分和私钥经过签名算法生成一个签名，判断与jwt第三部分的签名是否一致，如果一致就认证通过。



JWT和token区别：服务端验证客户端发送的`token`信息要进行数据的查询操作`Jwt`验证客户端发来的`token`就不用，在服务端使用密钥校验就可以了，不用数据库的查询。`Token`需要查库验证`token` 是否有效，而`JWT`不用查库或者少查库，直接在服务端进行校验，并且不用查库。因为用户的信息及加密信息在第二部分`payload`和第三部分签证中已经生成，只要在服务端进行校验就行，并且校验也是[JWT](https://so.csdn.net/so/search?q=JWT&spm=1001.2101.3001.7020)自己实现的。



node.js实现

> ```
> 前端部分（axios）：
> <!DOCTYPE html>
> <html lang="en">
> <head>
>     <meta charset="UTF-8">
>     <meta http-equiv="X-UA-Compatible" content="IE=edge">
>     <meta name="viewport" content="width=device-width, initial-scale=1.0">
>     <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
>     <title>Document</title>
> </head>
> <body>
>     <button id="btn" onclick="send()">发送jwt请求</button>
>     <button id="btn" onclick="check()">token验证</button>
> 
>     <script>
>         function send() {
>             console.log('11')
>             axios.post('http://localhost:8601/login', {
>             	//设置请求头
>                 Headers:{
>                     'Content-Type': 'application/json; charset=utf-8'
>                 },
>                 //配置请求体
>                 username:'haha',
>                 password:'haha'
>             }).then((res) => {
>             	//响应体返回后，将获得的Token放入localStorage中
>                 localStorage.setItem('token', res.data.token)
>                 console.log(res)
>             }).catch((error) => {
>                 console.log(error)
>             })
>         }
> 		//jwt验证
>         function check() {
>             console.log('check')
>             const token1 = localStorage.getItem('token')
>             axios.get('http://localhost:8601/afterLogin',{
>             	//请求头携带token验证
>                 headers:{
>                     authorization: token1
>                 }
>             })
>         }
> 			
>         axios.interceptors.request.use(function (request) {
>             // 在发送请求之前做些什么
>             console.log('请求拦截')
>             console.log(request.headers)
>             return request;
>         }, function (error) {
>             // 对请求错误做些什么
>             return Promise.reject(error);
>         });
> 
>         axios.interceptors.response.use(function (response) {
>             // 2xx 范围内的状态码都会触发该函数。
>             // 对响应数据做点什么
>             console.log(123)
>             console.log(response)
>             return response;
>         }, function (error) {
>             // 超出 2xx 范围的状态码都会触发该函数。
>             // 对响应错误做点什么
>             return Promise.reject(error);
>         });
>     </script>
> </body>
> </html>
> ```



> ```
> 后端部分（express、jwtwebtoken实现）：
> const express = require('express')
> const jwt = require('jsonwebtoken')
> const cors = require('cors')
> const server = express()
> 
> const jwtKey = 'migumigu'
> //调用json解析
> server.use(express.json())
> //设置跨域
> server.use(cors())
> server.all('*', function (req, res, next) {
>     //设置请求头
>     //允许所有来源访问
>     res.header('Access-Control-Allow-Origin', '*')
>     //用于判断request来自ajax还是传统请求
>     res.header("Access-Control-Allow-Headers", " Origin, X-Requested-With, Content-Type, Accept");
>     //允许访问的方式
>     res.header('Access-Control-Allow-Methods', 'PUT,POST,GET,DELETE,OPTIONS')
>     //修改程序信息与版本
>     res.header('X-Powered-By', ' 3.2.1')
>     //内容类型：如果是post请求必须指定这个属性
>     res.header('Content-Type', 'application/json;charset=utf-8')
>     next()
>   })
> 
> //设置对应方法的请求响应
> server.post('/login', (req, res) =>{
>     const {username , password} = req.body
>     //如果正确，生成jwt并返回
>     if(username == 'haha' && password == 'haha'){
>         jwt.sign(
>             {username},
>             jwtKey,
>             {expiresIn: '3600s'},
>             (err, token)=>{
>                 res.json({username,token,message:'登录成功！！！'})}
>         )
>     }
> })
> 
> server.get('/afterLogin', (req,res) => {
>     const headers = req.headers
>     const token = headers.authorization
> 	//jwt验证
>     jwt.verify(token, jwtKey, (err,payload) => {
>     	//验证失败，返回403
>         if(err){
>             res.sendStatus(403);
>             //记得return，不然会报错，因为响应两次了
>             return
>         }
>         //验证成功
>         res.json({message:'认证成功！', payload})
>     })
> })
> 
> server.listen(8601, ()=>{
>     console.log('监听成功！!')
> })
> ```









## 11、OSI七层网络

![image-20230525212017958](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202305252120206.png) 

作用：简而言之就是进行数据封装的

![image-20230525213956340](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202305252139454.png)





## 12、HTTP常用字段

* 常用请求头部字段

1、Accept：主要用来表示浏览器能够支持的内容类型有哪些。

2、accept-encoding：主要用来表示浏览器支持的压缩编码有哪些。

3、Accept-language：主要用来表示浏览器所支持的语言类型

4、user-agent：主要表示用户代理,服务器可以通过该字段识别出客户端的浏览器类客户端的操作系统及版本号型、浏览器版本号主要以伪造该字段进行网页排版引擎等客户端信息。

5、Connection：表示客户端与服务器的连接类型,对应的字段值主要有两种。keep-alive表示持久性连接。close表示单方面关闭连接,让连接断开。

6、Host：表示请求的服务器网址是什么。

7、Authorization：设置HTTP身份验证的凭证 

* 常用响应字段

1、content-type：服务端返回的资源类型，可以带上使用的编码格式。

2、content-encoding：返回资源使用的压缩格式。

3、Content-Length：HTTP 消息体的长度。

4、Date：HTTP 响应报文生成的时间，使用了 GMT 格式。

5、Connection：服务端决定使用长连接还是短连接。

6、Server：使用了哪种服务器。

7、Access-Control-Allow-Origin：指定哪些站点可以参与跨站资源共享 

8、Expires：设置响应体的过期时间

* HTTP缓存相关

请求头：

1、Cache-Control

2、Pragma

3、If-Modified-Since

4、If-None-Match

响应头：

1、Last-Modified

2、ETag





## 13、axios拦截器

一般在使用axios时，会用到拦截器的功能，一般分为两种：请求拦截器、响应拦截器。

请求拦截器：在请求发送前进行必要操作处理，例如添加统一cookie、请求体加验证、设置请求头等，相当于是对每个接口里相同操作的一个封装；

响应拦截器：同理，响应拦截器也是如此功能，只是在请求得到响应之后，对响应体的一些处理，通常是数据统一处理等，也常来判断登录失效等。
![image-20230603135214123](C:\Users\Samuel\AppData\Roaming\Typora\typora-user-images\image-20230603135214123.png)

每个拦截器都可以设置两个拦截函数，一个为成功拦截，一个为失败拦截。在调用axios.request()之后，请求的配置会先进入请求拦截器中，正常可以一直执行成功拦截函数，如果有异常会进入失败拦截函数，并不会发起请求；调起请求响应返回后，会根据响应信息进入响应成功拦截函数或者响应失败拦截函数。

> ```
> // 1.添加请求拦截器
> axios.interceptors.request.use(function (config) {
>     // 在请求体发送到服务器前，对发送请求做些什么
>     return config;
>   }, function (error) {
>     // 对请求错误做些什么
>     return Promise.reject(error);
>   });
> 
> // 2.添加响应拦截器
> axios.interceptors.response.use(function (response) {
>     // 在响应返回客户端前，对响应数据做点什么
>     return response;
>   }, function (error) {
>     // 对响应错误做点什么
>     return Promise.reject(error);
>   });
> ```





## 14、Koa和Express区别

Koa 使用的是一个洋葱模型，它的一个特点是级联，通过 await next() 控制调用 “下游” 中间件，直到 “下游” 没有中间件且堆栈执行完毕，最终在流回 “上游” 中间件。

1 、koa的next返回的是promise对象，使用await去修饰时，可以严格意义的保证洋葱圈模型的执行，不会受到同步任务或者异步任务的影响。而express的next返回void（koa可用于处理特定的异步情况），Express 中间件实现是基于 Callback 回调函数同步的，它不会去等待异步（Promise）完成。

2、koa可以使用内置router编写路由，但可读性较差，一般推荐使用koa-router（路由模块化）

3、koa url处理：在get请求中，如果以键值对的形式传参，可以通过query获得；在get请求中，如果参数通过路由传参，可以通过params得到

4、koa不支持body解析，需要使用中间件如koa-body  

5、响应机制：

Koa中：在 Koa 中数据的响应是通过 ctx.body 进行设置，注意这里仅是设置并没有立即响应，而是在所有的中间件结束之后做了响应。好处是我们在响应之前是有一些预留操作空间的。

Express：express 中我们直接操作的是 res 对象，在 Koa 中是 ctx，直接 res.send() 之后就立即响应了，这样如果还想在上层中间件做一些操作是有点难的。

## 15、Koa常见错误

常见分为三类：

1、404：请求资源不存在，或者没有`ctx.body`返回时，会由koa自动返回

2、手动抛出：通过`ctx.throw`手动抛出

3、500：运行时错误

处理方法：

由于koa类是继承node的emitter类的

1、通过emit提交一个错误

2、通过on进行统一错误处理 

> ```
> const app = new koa()
> ………………………………
> app.get('/users', (ctx) => {
> 	ctx.app.emit('error', {
> 		code:404,
> 		message:'无资源。'
> 	}, ctx)
> })
> 
> 
> app.on('error', (err, ctx) => {
> 	console.log(err)
> 	ctx.body = {
> 		code: err.status || 500,
> 		message: err.message,
> 	}
> })
> ```
>
> 

# HTML、CSS



## 1、HTML语义化

HTML5的语义化指的是`合理正确的使用语义化的标签来创建页面结构`。

语义化优点：

- 在`没CSS样式的情况下，页面整体也会呈现很好的结构效果`
- `代码结构清晰`，易于阅读，
- `利于开发和维护` 方便其他设备解析（如屏幕阅读器）根据语义渲染网页。
- `有利于搜索引擎优化（SEO）`，搜索引擎爬虫会根据不同的标签来赋予不同的权重



## 2、CSS选择器

选择器类型：

**选择器：**

- id选择器(#myid)
- 类选择器(.myclass)
- 属性选择器(a[rel="external"])
- 伪类选择器(a:hover, li:nth-child)
- 标签选择器(div, h1,p)
- 相邻选择器（h1 + p）
- 子选择器(ul > li)
- 后代选择器(li a)
- 通配符选择器(*)

**优先级：**

- `!important`
- 内联样式（1000）
- ID选择器（0100）
- 类选择器/属性选择器/伪类选择器（0010）
- 元素选择器/伪元素选择器（0001）
- 关系选择器/通配符选择器（0000）



## 3、position属性

**固定定位 fixed**： 元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定 位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重叠。

**相对定位 relative**： 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直 或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是 否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。

**绝对定位 absolute**： 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那 么它的位置相对于。absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。

**粘性定位 sticky**： 元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定 位，之后为固定定位。

**默认定位 Static**： 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。inherit: 规定应该从父元素继承 position 属性的值。



## 4、box-sizing属性

box-sizing 属性定义如何计算一个元素的总宽度和总高度，主要设置是否需要加上内边距(padding)和边框等。

content-box：指定盒模型为 W3C 标准模型，设置 border、padding 会增加元素 width与 height 的尺寸。

border-box：指定盒模型为 IE模型（怪异模式），设置 border、padding 不会影响元素 width 与 height 的尺寸。



## 5、CSS盒子模型

CSS 盒模型本质上是一个盒子，它包括：边距，边框，填充和实际内容。CSS 中的盒子模型包括标准盒模型和怪异盒模型

标准盒模型： 一个块的总宽度 = width+	margin(左右)+padding(左右)+border(左右) 

怪异盒模型：一个块的总宽度 = width+margin（左右）（既 width 已经包含了 padding 和 border 值）



## 6、BFC

定义：块级格式化上下文，独立的渲染区域，这个区域的子元素不会影响到外面的元素

形成的条件：a.浮动 b. 非静态定位，c. overflow:hidden d. display:table 

解决的问题：a. 浮动元素重叠（让父元素的高度包含子浮动元素） b. 父元素高度塌陷 b. margin重叠



## 7、居中

**水平居中**

- 对于 行内元素 : `text-align: center`;

- 对于确定宽度的块级元素：

  （1）width和margin实现。`margin: 0 auto`;

  （2）绝对定位和margin-left: (父width - 子width）/2, 前提是父元素position: relative

- 对于宽度未知的块级元素

  （1）`table标签配合margin左右auto实现水平居中`。使用table标签（或直接将块级元素设值为 display:table），再通过给该标签添加左右margin为auto。

  （2）inline-block实现水平居中方法。display：inline-block和text-align:center实现水平居中。

  （3）`绝对定位+transform`，设置元素相对父级定位`position:absolute;left:50%;top:50%`，让自身平移自身高度50% ，然后`transform:translate(-50%,-50%)`，这种方式兼容性好，被广泛使用的一种方式

  （4）flex布局使用`justify-content:center`



**垂直居中**

1. 利用 `line-height` 实现居中，这种方法适合纯文字类
2. 通过设置父容器 相对定位 ，子级设置 `绝对定位`，然后top、left、right、bottom设为0，标签通过margin实现自适应居中
3. 弹性布局 flex :父级设置display: flex; 子级设置margin为auto实现自适应居中
4. 父级设置相对定位，子级设置绝对定位，并且通过位移 transform 实现
5. `table 布局`，父级通过转换成表格形式，`然后子级设置 vertical-align 实现`。（需要注意的是：vertical-align: middle使用的前提条件是内联元素以及display值为table-cell的元素）。



## 8、隐藏页面中某元素

1.`opacity：0`，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定 一些事件，如click 事件，那么点击该区域，也能触发点击事件的

2.`visibility：hidden`，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已 经绑定的事件 ，隐藏对应元素，在文档布局中仍保留原来的空间（重绘）

3.`display：none`，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素。 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）





## 9、页面布局

* Flex

容器的属性：

- flex-direction：决定主轴的方向（即子 item 的排列方法）flex-direction: row | row-reverse | column | column-reverse;
- flex-wrap：决定换行规则 flex-wrap: nowrap （不换）| wrap（超出就换） | wrap-reverse（和warp相反）;
- flex-flow： .box { flex-flow: || ; }
- justify-content：对其方式，水平主轴对齐方式
- align-items：对齐方式，副轴线方向，适用于单行
- align-content：同align-items，不过适用于多行

项目的属性（元素的属性）：

- order 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0
- flex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大
- flex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果 定义个 item 的 flow-shrink 为 0，则为不缩小
- flex-basis 属性：定义了在分配多余的空间，项目占据的空间。
- flex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。
- align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖
- align-items，默认属 性为 auto，表示继承父元素的 align-items 比如说，用 flex 实现圣杯布局



* rem布局

首先 Rem 相对于根(html)的 font-size 大小来计算。简单的说它就是一个相对单例 如:font-size:10px;,那么（1rem = 10px）了解计算原理后首先解决怎么在不同设备上设置 html 的 font-size 大小。其实 rem 布局的本质是等比缩放，一般是基于宽度。

**优点**：可以快速适用移动端布局，字体，图片高度

**缺点**：

①目前 ie 不支持，对 pc 页面来讲使用次数不多；
 ②数据量大：所有的图片，盒子都需要我们去给一个准确的值；才能保证不同机型的适配；
 ③在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小。也就是说 css 样式和 js 代码有一定的耦合性。且必须将改变 font-size 的代码放在 css 样式之前。



* 百分比布局

​		流式布局，就是百分比布局，也称非固定像素布局。通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。流式布局方式是移动web开发使用的比较常见的布局方式。

​		通过百分比单位 " % " 来实现响应式的效果。通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。 直观的理解，我们可能会认为子元素的百分比完全相对于直接父元素，height 百分比相 对于 height，width 百分比相对于 width。 padding、border、margin 等等不论是垂直方向还是水平方向，都相对于直接父元素的 width。 除了 border-radius 外，还有比如 translate、background-size 等都是相对于自身的。



**缺点**：

（1）计算困难
 （2）各个属性中如果使用百分比，相对父元素的属性并不是唯一的。造成我们使用百分比单位容易使布局问题变得复杂。



* 浮动布局

浮动布局:当元素浮动以后可以向左或向右移动，直到它的外边缘碰到包含它的框或者另外一个浮动元素的边框为止。元素浮动以后会脱离正常的文档流，所以文档的普通流中的框就变的好像浮动元素不存在一样。

**优点**

这样做的优点就是在图文混排的时候可以很好的使文字环绕在图片周围。另外当元素浮动了起来之后，它有着块级元素的一些性质例如可以设置宽高等，但它与inline-block还是有一些区别的，第一个就是关于横向排序的时候，float可以设置方向而inline-block方向是固定的；还有一个就是inline-block在使用时有时会有空白间隙的问题

**缺点**

最明显的缺点就是浮动元素一旦脱离了文档流，就无法撑起父元素，`会造成父级元素高度塌陷`。



清除浮动方法：

1、添加额外标签清除浮动。

```
<div class="parent">
    <div class="f"></div>
    //添加额外标签并且添加clear属性
    <div style="clear:both"></div>
</div>
```



2、父元素设置`overflow:hidden`

```
<div class="parent" style="overflow:hidden">
    //将父元素的overflow设置为hidden
    <div class="f"></div>
</div>
```



3、父元素设置`overflow:auto`

```
<div class="parent" style="overflow:auto">
    //将父元素的overflow设置为hidden
    <div class="f"></div>
</div>
```



4、父元素也设置为浮动元素



5、使用伪元素`:after`

```
//在css中添加:after伪元素
.parent:after{
    content:"";
    visibility:hidden;
    display:block;
    width:100%;
    height:0;
    clear:both;
}

<div class="parent">
    <div class="f"></div>
</div>
```



## 10、重排和重绘

`重排/回流（Reflow）`：当`DOM`的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。

`重绘(Repaint)`: 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变。



* 如何触发重排和重绘？

添加、删除、更新DOM节点

通过display: none隐藏一个DOM节点-触发重排和重绘

通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化

移动或者给页面中的DOM节点添加动画

添加一个样式表，调整样式属性

用户行为，例如调整窗口大小，改变字号，或者滚动。



* 如何避免重绘和重排

JavaScript优化法
（1）避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
（2）避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中，也就是虚拟DOM
（3）避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
CSS优化法
（1）使用 transform 替代 top
（2）使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局 （3）避免使用table布局，可能很小的一个小改动会造成整个 table 的重新布局。
（4）尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。
（5）避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。
（6）将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。
（7）避免使用CSS表达式，可能会引发回流。
（8）将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。
（9）CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。



##  11、三角形

> ```
> border-top: 50px solid transparent;
> 
> border-bottom: 50px solid transparent;
> 
> border-left: 50px solid #000;
> ```





# Vue

## 1、SPA和MVC和MVVM

1、SPA：整个项目只有一个html文件，路由切换进行页面切换

优点：

​	一、用户体验及交互比较流畅

​	二、提取组件开发，易于后期维护

​	三、减轻服务器压力

缺点：

​	一、不利于SEO优化（搜索引擎优化），搜索引擎爬虫只会爬html，不会爬js

​	二、第一次进入比较慢（已有按需加载策略）



2、MVC和MVVM架构

​	一、MVC：View接受用户行为通知controller，controller通知model进行数据更新

​	Model通过View进行页面更新

​	Model和View进行交互

![image-20230311170844026](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303111708141.png)

​	二、MVVM：数据双向绑定

​		`视图模型双向绑定`，是`Model-View-ViewModel`的缩写，也就是把`MVC`中的`Controller`演变成`ViewModel。Model`层代表数据模型，`View`代表UI组件，`ViewModel`是`View`和`Model`层的桥梁，数据会绑定到`viewModel`层并自动将数据渲染到页面中，视图变化的时候会通知`viewModel`层更新数据。以前是操作DOM结构更新视图，现在是`数据驱动视图`。





**Observer（数据监听器）** : Observer的核心是通过Object.defineProprtty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher

**Watcher（订阅者）** : Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是：

1. 在自身实例化时往属性订阅器(dep)里面添加自己
2. 自身必须有一个update()方法
3. 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调

**Compile（指令解析器）** : Compile主要做的事情是解析模板指令，将模板中变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加鉴定数据的订阅者，一旦数据有变动，收到通知，更新试图



![img](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303231547636.png)

​		用户行为更改数据，数据可以主动触发视图更新

​		双向绑定通过ViewModel进行交互

​		Model和View不直接进行交互

![image-20230311171248215](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303111712276.png)



## 2、vue2/3生命周期

**Vue2**

> ```
> <body>
>  <div id="app">
>      {{msg}}
>  </div>
>  <button id="btn">删除</button>
> </body>
> </html>
> 
> <script>
>  const app = new Vue({
>      el:"#app",
>      data: {
>          msg:"你好！",
>          msg2:"不好！"
>      },
>      beforeCreate() {
>          console.log("beforeCreate,挂载了vue实例的方法，但data还没挂载", this.msg)
>      },
>      created() {
>          console.log("created, 挂载了data", this.msg)
>      },
>      beforeMount() {
>          console.log("data没有渲染到页面", document.getElementById("app").innerHTML)
>      },
>      mounted() {
>          console.log("mounted data渲染到了页面", document.getElementById("app").innerHTML)
>          setTimeout(() => {
>              this.msg = "hello!"
>          }, 2000);
>      },
>      beforeUpdate() {
>          console.log("beforeUpdate数据更改直到DOM更改之前", document.getElementById("app").innerHTML)//只有数据更变(data中)和dom更改(div中)两个条件都达成了，才会触发update
>      },
>      updated() {
>          console.log("update数据更改导致DOM更改之后", document.getElementById("app").innerHTML)//只有数据更变和dom更改两个条件都达成了，才会触发update
>      },
>      beforeDestroy() {
>          console.log("beforeDestroy!")
>      },
>      destroyed() {
>          console.log("destroyed!")
>      },
>  })
>  document.getElementById("btn").onclick = () => {
>      app.$destroy()
>  }
> </script>
> ```

建议运行感受一哈！

![image-20230311182622845](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303111826919.png)



**Vue3**

> ```
> <body>
>  <div id="app">
>      {{msg}}
>  </div>
> </body>
> </html>
> <script>
>  const {createApp, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted, ref} = Vue
>  const app = createApp({
>      //vue3 删除了beforeCreate created 用 setup代替
>      //destroy 改为了 unmount
>      setup:(props) => {
>          msg = ref("Hi~~~")
>          console.log('data没有渲染页面噢！')
>          onBeforeMount(()=>{
>              console.log("onBeforeMount data没有渲染到页面", document.getElementById("app").innerHTML)
>          }),
>          onMounted(()=>{
>              console.log("onMounted data渲染到了页面", document.getElementById("app").innerHTML)
>              setTimeout(() => {
>                  msg.value = "hello!"
>              }, 2000);
>          }),
>          onBeforeUpdate(() => {
>              console.log("更新前")
>          }),
>          onUpdated(() => {
>              console.log("更新后")
>          }),
>          onBeforeUnmount(() => {
>              console.log("销毁前")
>          }),
>          onUnmounted(() => {
>              console.log("销毁后")
>          })
>          return {msg}
>      }
>  }).mount("#app")
> </script>
> ```

![image-20230311182721353](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303111827410.png)



## 3、watch和computed

**computed**：计算属性，计算出一个结果，函数值改变会导致重新计算

1、初始化的时候会自动计算一次

2、computed会读取缓存数据，后面不改变值的话，就会取用缓存数据



**watch**：监控某个数据，被监控的数据更改，则watch执行

> ```
> <script setup>
> import {ref , computed, watch,onMounted} from "vue"
> const num1 = ref(1)
> // computed: 计算属性，计算出一个结果，函数值改变会导致重新计算
> // 初始化的时候会自动计算一次
> // computed会读取缓存数据
> const num2 = computed(() => {
> console.log('computed执行')
> return num1.value  + 10
> })
> //watch：监控某个数据，被监控的数据更改，则watch执行
> const num3 = ref('未成年')
> watch(num1,(newValue, oldValue)=>{
> console.log('watch执行')
> if(newValue > 18){
>  num3.value = '已成年'
> }
> })
> onMounted(()=>{
> setTimeout(()=>{
>  num1.value += 20
> }, 2000)
> })
> </script>
> 
> <template>
> <div>
>  <p>小红年龄{{num1}}</p>
>  <p>小红哥哥年龄{{num2}}</p>
>  <p>小红{{num3}}</p>
> </div>
> </template>
> ```



## 4、router、routes和route

router：路由对象； routes：路由配置； route：当前路由信息

1、router：路由器（new的路由器对象），包含一些操作路由的功能函数，来实现编程式导航。一般指的是在任何组件内访问路由。如：路由编程式导航的$router.push()
2、routes：指创建vue-router路由实例的配置项。用来配置多个route路由对象
3、route：指路由对象表示当前激活的路由的状态信息。一般用来获取页面信息.如：this.$route指的是当前路由对象，path/meta/query/params



Vue-Router的hash模式和history模式

hash模式：

即地址栏 URL 中的 # 符号，如haha/#/123，hash值即#/123，改变hash值不会被放入http请求中，后端不受影响。

过程：当#号后面的路径改变时，会触发hashchange事件，在事件回调中会无刷新进行页面转跳。



history模式：

两个核心API（history.pushState和history.replaceState），history.pushState用于追加历史记录，history.replaceState用于替换当前历史记录

history模式刷新有可能会返回404（刷新会触发get请求，发送http请求），因为url没有匹配的静态资源。可以设定重定向，没有找到url对应页面，则重定向至根页面。



## 5、v-if和v-show

v-if：控制元素是否渲染（动态的向DOM树中添加或删除DOM元素）

v-show：控制的是样式的 display：none



共同点：

 在 vue 中 v-show 与 v-if 的作用效果是相同的(不含v-else)，都能控制元素在页面是否显示 。

- 当表达式都为 false 时，都不会占据页面位置
- 当表达式结果为 true 时，都会占据页面的位置



不同点：

v-show 是通过控制display属性来进行dom的显示与隐藏

v-if 是真正意义上的条件渲染，为true是渲染（dom存在），为false时不存在（dom不存在）

v-if 与 v-show 都能控制dom元素在页面的显示

v-if 相比 v-show 开销更大的（直接操作dom节点增加与删除）

如果需要非常频繁地切换，则使用 v-show 较好

如果在运行时条件很少改变，则使用 v-if 较好





## 6、vue组件传参

* 父传子：props

<父组件通过标签属性进行数据传递>

子组件通过defineProps获取父组件传过来的数据

子组件不允许更改父组件的数据

* 子传父：emit

emits触发组件的自定义事件

* 兄弟组件传参：事件总线bus Vue3使用mitt插件

事件总线：相当于全局的时间管理

使用：

​	mitt.emit('方法名',参数)：触发某个方法

​	mitt.on('对应方法名', callback)：监听某个方法

​	mitt.off('移除对应方法')：移除某个方法，一般放再onUnmounted声明周期里面



## 7、Vue项目中key的作用

- key的作用是为了在diff算法执行时更快的找到对应的节点，`提高diff速度，更高效的更新虚拟DOM`;

  Vue	是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。

- 为了在数据变化时强制更新组件，以避免`“就地复用”`带来的副作用。

  当 Vue.js 用 `v-for` 更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。重复的key会造成渲染错误。



## 8、Vuex

Vuex 是一个专为 Vue 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。

1. Vuex 的状态存储是响应式的；当 Vue 组件从 store 中读取状态的时候，

若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新 2. 改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation， 这样使得我们可以方便地跟踪每一个状态的变化 Vuex主要包括以下几个核心模块：

1. State：定义了应用的状态数据
2. Getter：在 store 中定义“getter”（可以认为是 store 的计算属性），

就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来， 且只有当它的依赖值发生了改变才会被重新计算 3. Mutation：是唯一更改 store 中状态的方法，且必须是同步函数 4. Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作 5. Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中



vuex刷新时，数据会丢失，如何解决？







## 9、Diff算法

​		每一个真实的dom都有对应的一个虚拟dom，即一个JS对象。当一个dom发生变化时候，其虚拟dom也会发生变化，这时就需要判断前后两个虚拟dom的变化，找出两者差异，这时候就需要diff算法找出差异，然后最小化更新视图。本质就是比较两个JS对象的差异。

![image-20230325134724365](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303251347564.png)

updateChildren

 1、同级比对 2、首尾比对

![image-20230325134745100](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303251347247.png)

真实DOM的位置以比较后newVnode的位置为基准。当新旧节点中其中一个有end和start相交，结束。

Diff算法主要就是在虚拟DOM树发生变化后，生成DOM树更新补丁的方式，对比新旧两株虚拟DOM树的变更差异，将更新补丁作用于真实DOM，以最小成本完成视图更新；2、框架会将所有的结点先转化为虚拟节点Vnode，在发生更改后将VNode和原本页面的OldNode进行对比，然后以VNode为基准，在oldNode上进行准确的修改。（修改准则：原本没有新版有，则增加；原本有新版没有，则删除；都有则进行比较，都为文本结点则替换值；都为静态资源不处理；都为正常结点则替换）



## 10、常用指令

{{}} 两个大括号 双向绑定值语法

v-text 编译成文字段落

v-html 把html代码段编译成元素

v-bind 简写 : 绑定值成变量

v-for 循环

v-if、v-else-if、v-else 条件渲染（不占位）

v-show 条件渲染（占位）

v-on 简写 @ 一般用来绑定事件

v-pre 跳过编译（几乎99%不会用）

v-once 仅渲染一次（几乎99%不会用）

v-cloak 插值闪烁问题

v-model 双向绑定值，利用Object.defineProperty



## 11、ref和reactive区别

* 从定义数据方面：
  ref通常用来定义基本类型数据
  reactive用来定义：对象（或者数组）类型数据
  ref也可以用来定义对象或者数组类型的数据，内部会通过reactive转为代理对象
* 从原理方面：
  ref通过Object.defineProperty()的get和set实现数据代理。
  reactive使用Proxy实现数据代理，并且通过Reflect操作源对象内部的数据。
* 从使用方面：
  ref操作数据需要.value，template模板中不需要。
  reactive都不需要.value



## 12、template渲染

Vue 推荐在绝大多数情况下使用 template 来创建你的 HTML。但是模板毕竟是模板，不是真实的dom节点。从模板到真实dom节点还需要经过一些步骤

1. 把模板编译为render函数
2. 实例进行挂载, 根据根节点render函数的调用，递归的生成虚拟dom
3. 通过diff算法对比虚拟dom，渲染到真实dom（类同react的虚拟DOM渲染过程）
4. 组件内部data发生变化，组件和子组件引用data作为props重新调用render函数，生成虚拟dom, 返回到步骤3



模板 -> render函数 -> render函数 返回vnode虚拟dom --(通过snabbdom的patch函数，将虚拟dom放入真实dom节点中)-> 真实dom

模板里的所有模块，会存放在App对象的render函数中

![image-20230418173119753](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202304181731905.png)





## 13、自定义函数（bind、inserted钩子函数）

自定义指令其实是个对象，里面有不同的钩子函数，bind是指令绑定到元素上执行的钩子函数，inserted是绑定元素插入到父级元素时会执行的钩子函数，update是指令再模板结构被重新解析时执行的钩子函数。

1. 指令定义时不加v-，但使用时要加v-



> ```
> <div id="root">
> 	放大10倍后的n值是：<span v-big="n"></span>
> 	<button @click="n++">点我n+1</button>
> 	
> 	<input type="text" v-fbind:value="n">
> </div>
> ```

> ```
> new Vue({
> 	el: '#root',
> 	data: {
> 		n: 1
> 	},
> 	directives: {
> 		// big函数何时会被调用？1. 指令与元素成功绑定时（一上来）；2. 指令所在的模板被重新解析时 
> 		// bind函数和update函数中的逻辑一样
> 		big(element, binding) {
> 			console.log(element, binding);
> 			element.innerText = binding.value * 10;
> 		},
> 		fbind: {
> 			// 指令与元素成功绑定时
> 			bind(element, binding) {
> 				//el是当前元素，binding可以获得传入的value
> 				element.value = binding.value;
> 			},
> 			// 指令所在元素被插入到页面时
> 			inserted(element, binding) {
> 			//binding可以获得当前元素的父元素，此时已经插入，而bind的binding中没有
> 				element.focus();	
> 			},
> 			// 指令所在的模板被重新解析时
> 			update(element, binding) {
> 				element.value = binding.value;
> 			}
> 		}
> 	}
> });
> 
> ```
>





## 14、Vue2/3区别

1、双向绑定原理

**vue2** 的双向数据绑定是利用ES5 的一个 API `Object.definePropert()`对数据进行劫持 结合 发布订阅模式的方式来实现的。

**vue3** 中使用了 es6 的 `Proxy`API 对数据代理。

使用proxy的优势如下

1. defineProperty只能监听某个属性，不能对全对象监听；Proxy 可以直接监听对象而非属性；
2. 可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）
3. 可以监听数组，不用再去单独的对数组做特异性操作 vue3.x可以检测到数组内部数据的变化
4. Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；



2、Vue3支持碎片（Fragments）

即在组件中可以拥有多个根节点，解决了多个div嵌套的问题



3、composition API

Vue2使用选项类型API（Options API）对比Vue3合成型API（Composition API）

> 旧的选项型API在代码里分割了不同的属性: data,computed属性，methods，等等。新的合成型API能让我们用方法（function）来分割，相比于旧的API使用属性来分组，`这样代码会更加简便和整洁`。



4、生命周期钩子

> ```
> Vue2--------------vue3
> beforeCreate  -> setup()
> created       -> setup()
> beforeMount   -> onBeforeMount
> mounted       -> onMounted
> beforeUpdate  -> onBeforeUpdate
> updated       -> onUpdated
> beforeDestroy -> onBeforeUnmount
> destroyed     -> onUnmounted
> activated     -> onActivated
> deactivated   -> onDeactivated
> ```

setup() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method
onBeforeMount() : 组件挂载到节点上之前执行的函数。
onMounted() : 组件挂载完成后执行的函数。
onBeforeUpdate(): 组件更新之前执行的函数。
onUpdated(): 组件更新完成之后执行的函数。
onBeforeUnmount(): 组件卸载之前执行的函数。
onUnmounted(): 组件卸载完成后执行的函数
若组件被<keep-alive>包含，则多出下面两个钩子函数。
onActivated(): 被包含在中的组件，会多出两个生命周期钩子函数。被激活时执行 。
onDeactivated(): 比如从 A组件，切换到 B 组件，A 组件消失时执行。

**setup()函数阶段**
在setup()函数阶段，您可以做一些准备性的工作。您可以定义响应式数据、计算属性、方法等等。但是，您需要注意的是，由于setup()函数是在组件实例化之前调用的，因此您无法访问到this上下文并且应该使用第二个参数—— context 对象。context 包含了一些有用的属性和方法，比如如何访问父级或子级组件等。在setup()函数中定义的数据和方法将不会在模板中直接使用，如果需要在模板中使用，则需要通过 return 语句把它们暴露出去。

**onBeforeMount()和onMounted()阶段**
在组件进入onBeforeMount()阶段时，Vue 3会创建虚拟DOM并将其与组件关联起来。在该阶段中，您可以访问组件的DOM，并在挂载期之前对其进行修改。在组件进入onMounted()阶段后，Vue 3完成了组件的挂载。在此阶段，您可以进行一些副作用操作（如API调用、添加事件监听器等）。

**onBeforeUpdate()和onUpdated()阶段**
在组件进入onBeforeUpdate()阶段时，Vue 3检测到响应式数据发生了变化，并准备重新渲染组件。在该阶段，您可以访问并修改组件的DOM。在组件进入onUpdated()阶段后，Vue 3完成了重新渲染。在此阶段，您可以进行一些副作用操作（如API调用、添加事件监听器等）。

**onBeforeUnmount()和onUnmounted()阶段**
在组件进入onBeforeUnmount()阶段时，Vue 3已经准备卸载组件。在该阶段，您可以执行一些销毁操作（如取消订阅、清除计时器等）。在组件进入onUnmounted()阶段后，Vue 3完成了组件的卸载。在此阶段，您不能访问组件的DOM或响应式数据。

5、父子传参不同、setup（）特性

总结：
1、setup 函数时，它将接受两个参数：（props、context(包含attrs、slots、emit)）

2、setup函数是处于 生命周期函数 beforeCreate 和 Created 两个钩子函数之前的函数

3、执行 setup 时，组件实例尚未被创建（在 setup() 内部，this 不会是该活跃实例的引用，即不指向vue实例，Vue 为了避免我们错误的使用，直接将 setup函数中的this修改成了 undefined）

4、与模板一起使用：需要返回一个对象 (在setup函数中定义的变量和方法最后都是需要 return 出去的 不然无法再模板中使用)

5、使用渲染函数：可以返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态

注意：setup 函数中的 props 是响应式的，当传入新的 prop 时，它将被更新。但是，因为 props 是响应式的，你不能使用 ES6 解构，因为它会消除 prop 的响应性。







# 浏览器

## 1、CSRF攻击

概念：跨域请求伪造。2.原理：诱导用户跳转到新的页面，利用 服务器的验证漏洞 和 用户之前的登入状态，来模拟用户进行操作。3.防范：利用cookie的sameSize属性规定其他网站不能使用本网站的cookie。或者使用token验证，再去验证用户身份。



## 2、XSS攻击

XSS指跨站脚本攻击，是攻击者通过向被攻击网站注入恶意代码实现攻击，当被攻击者登录这些网站是就会执行恶意代码，读取cookie、session cookie以及其他敏感信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等



## 3、缓存

概念：浏览器首先向浏览器缓存发出请求，根据强制缓存规则判断是否向服务器发起请求。

* 缓存位置：
  from memory：内存缓存，可快速读取，在进程关闭后会被清空。
  在浏览器中，JS文件、图片等解析后被放入内存。
  from disk： 硬盘缓存，需要对硬盘进行I/O操作，读取复杂，
  在浏览器中，CSS文件会存入硬盘，每次渲染页面从硬盘中读取。
* 如果有缓存内容，判断该缓存是否过期：
  没有过期，读取该缓存，加载内容。
  如果过期了，浏览器携带该缓存的相关标识向服务器发起请求，根据协商缓存规则进行处理。
  服务器返回结果为304表示可以继续使用该缓存，浏览器会读取该缓存，加载内容。
  服务器返回结果为200表示资源过期了，同时返回新的资源和缓存标识，浏览器更新缓存内容和标识，并加载新内容。
* 如果没有缓存，会直接向服务器发起请求。服务器返回200和资源与标识，浏览器根据相关Cache-Control判断是否要缓存，加载内容。



## 4、强制缓存

* 规则：浏览器第一次请求服务器时，服务器会把缓存规则放在响应头里，和**资源**一起返回给浏览器。强制缓存的控制字段为Expires和Cache-Control，其中Cache-Control优先级高于Expires。
* 强制缓存的思想是，在浏览器内置数据库中缓存每次请求中 “可以被缓存” （受到一些关键字的管控）的静态资源如 image, css, js 文件， 当第二次请求被缓存过的资源时候，会通过校验两个字段 Expires 和 Cache-Control 的max-age字段（注意，Expires 是 http1.0 的产物， Cache-Control 则是 http1.1 的产物。 两者同时存在， 或者只存在其中之一， 都可以触发强制缓存）

![img](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202304182248282.png)

![image-20230418223033360](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202304182230543.png)



## 5、协商缓存

* 在强制缓存失效后，浏览器携带缓存标识向服务器发起请求，查询该缓存是否可用。服务器返回的结果：
  * 304：资源无更新，浏览器可以继续使用缓存中的资源。
  * 200：资源更新了，同时返回新的资源和资源标识，浏览器需要更新缓存
* 规则：依据reponse / request头中的Last-Modified / If-Modified-Since 和 Etag / If-None-Match字段

![image-20230418223302714](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202304182233780.png)



​		浏览器首次向服务器请求数据 A， 服务器正常返回数据，同时在响应头中放入 ETag 和 Last-Modified 两个新字段。

​		当浏览器第二次向服务器请求数据 A 时， 浏览器会自动地在请求头附上 If-None-Match 和 If-Modified-Since 两个字段（分别对应的是 ETag 和 Last-Modified 的值，两两相等）， 然后由服务器端进行校验， 校验通过的话（表明数据有效）， 服务器会直接返回 状态码 304 ，且不携带响应体的报文段， 这相当于告诉浏览器：当前缓存有效， 可以直接使用！ 校验失败则会和首次请求一样， 返回状态码为200且携带数据响应体的报文段， 同时这个响应头会带上新的ETag 和Last-Modified， 为下一次协商缓存做好铺垫 。

![](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202304182255820.png)



## 6、缓存机制区别



1、强制缓存在缓存有效的情况下不会去请求服务器， 其数据来源则是浏览缓存的本地磁盘。而协商缓存会向服务器请求，但是在协商缓存成功的情况下， 服务器只会返回一个不带响应体的报文，结合开头的背景来说 强制缓存选择“减少过桥次数”的策略， 而协商缓存则是采用 ‘减少过桥人数’的策略
2、强制缓存在浏览器强制刷新的情况下不会生效， 而协商缓存则不受影响。（调试代码测试时候，要注意）
3、强制缓存返回的报文状态码为 200， 协商缓存返回的报文状态码为 304 （前端使用fetch请求的情况， 协商缓存的 状态码304 会转成 200）
4、强制缓存发生在浏览器端， 协商缓存发生在服务器端









## 7、点击刷新或按F5、按Ctrl+F5强制刷新、地址栏回车的区别

* 点击刷新或按F5：强制缓存直接失效，浏览器直接对本地的缓存文件过期，携带If-Modified-Since、If-None-Match进行协商缓存。
* 按Ctrl+F5强制刷新：浏览器对本地文件过期，并认为本地没有任何缓存文件，相当于第一个请求服务器。
* 地址栏回车：按正常流程，先判断是否有缓存、在强制缓存、最后协商缓存。
  

## 8、cookie 、sessionStorage、localStorage

* cookie

html5标准前本地存储的主要方式，请求头会自带cookie，大小只有4K；每个domain限制20个cookie。

cookie字段设置：name、value、domain、path、secure、httponly、max-age/expires



***cookie、session、token***

**session**：在服务器端记录，每一个会话会产生一个sessionId。当用户打开某个web应用时，便与web服务器产生一次session。服务器使用 sessionId 把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。所以服务器根据sessionId来区分用户。
缺点：单服务器时，用户量过大导致存放session的消耗过大。分布式服务器，如果登录的请求和后续使用的请求经负载均衡后打到不同的服务器，后续服务器没有存储之前的会话信息，会认为用户没有登录。由于服务端存储session比较麻烦，所以产生了cookie。
**cookie：**是服务端保存在客户端的临时的少量的数据， 由服务器生成，发送给浏览器。浏览器把cookie以键值对的形式保存到当前目录的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。
缺点：由于cookie存在客户端上，容易被攻击，所以产生了token。
**token：**服务端生成的一串字符串，当作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token并将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。



* localStorage

HTML5加入的以键值对的方式存储，永久性存储，大小为5M。



* sessionStorage

与localStorage类似，但是当页面关闭后会被清理，且不能再所有同源窗口中共享，是会话级别的存储方式。

![image-20230418223916102](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202304182239173.png)













# Webpack

## 1、优化 Webpack 的构建速度

- 使用高版本的 Webpack （使用webpack4）
- 多线程/多实例构建：HappyPack(不维护了)、thread-loader
- 缩小打包作用域：
  - exclude/include (确定 loader 规则范围)
  - resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)
  - resolve.extensions 尽可能减少后缀尝试的可能性
  - noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)
  - IgnorePlugin (完全排除模块)
  - 合理使用alias
- 充分利用缓存提升二次构建速度：
  - babel-loader 开启缓存
  - terser-webpack-plugin 开启缓存
  - 使用 cache-loader 或者 hard-source-webpack-plugin
     注意：thread-loader 和 cache-loader 兩個要一起使用的話，請先放 cache-loader 接著是 thread-loader 最後才是 heavy-loader

* DLL：使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。

## 2、优化 Webpack 的打包体积

- 压缩代码
- 提取页面公共资源：
- Tree shaking
- Scope hoisting
- 图片压缩
- 动态Polyfill



## 3、webpack构建流程

​		Webpack启动后，从entry开始，去递归解析entry依赖的所有module，再找到每一个module的时候，会根据module.rules里配置的不同loader进行相应的转换，对module进行转换后再解析出当前module依赖的其他的一些模块，这些module在entry里面，它会进行分组，解析成一个个的chunk，最后webpack会将所有chunk转换成文件输出的output，在整个构建流程中，通过plugin注入钩子，最后输出多个模块组合成的文件。





## 4、vite和webpack区别

1.开发模式不同

Webpack在开发模式下依然会对所有模块进行打包操作，虽然提供了热更新，但大型项目中依然可能会出现启动和编译缓慢的问题；而Vite则采用了基于ES Module的开发服务器，只有在需要时才会编译对应的模块，大幅度提升了开发环境的响应速度。

2.打包效率不同

Webpack在打包时，会把所有的模块打包成一个bundle，这会导致初次加载速度较慢；而Vite则利用了浏览器对ES Module的原生支持，只打包和缓存实际改动的模块，从而极大提高了打包效率。

3.插件生态不同

Webpack的插件生态非常丰富，有大量社区和官方插件可以选择，覆盖了前端开发的各个方面；而Vite的插件生态尽管在不断发展，但相比Webpack来说还显得较为稀少。

4.配置复杂度不同

Webpack的配置相对复杂，对新手不够友好；而Vite在设计上更注重开箱即用，大部分场景下用户无需自己写配置文件。

5.热更新机制不同

Webpack的热更新需要整个模块链重新打包和替换，对于大型项目可能会有延迟；Vite的热更新则只会针对改动的模块进行更新，提高了更新速度。

# Babel

## 1、Babel编译过程

Babel 是一个 JavaScript 编译器，是一个工具链，主要用于将采用 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。

`Babel` 本质上就是在操作 `AST` 来完成代码的转译。AST是抽象语法树（Abstract Syntax Tree, AST）

`Babel` 的功能很纯粹，它只是一个编译器。大多数编译器的工作过程可以分为三部分：

1. **解析（Parse）** ：将源代码转换成更加抽象的表示方法（例如抽象语法树）。包括词法分析和语法分析。词法分析主要把字符流源代码（Char Stream）转换成令牌流（ Token Stream），语法分析主要是将令牌流转换成抽象语法树（Abstract Syntax Tree，AST）。
2. **转换（Transform）** ：通过 Babel 的插件能力，对（抽象语法树）做一些特殊处理，将高版本语法的 AST 转换成支持低版本语法的 AST。让它符合编译器的期望，当然在此过程中也可以对 AST 的 Node 节点进行优化操作，比如添加、更新以及移除节点等。
3. **生成（Generate）** ：将 AST 转换成字符串形式的低版本代码，同时也能创建 Source Map 映射。





# Git

## 1、基本指令

git clone 仓库地址
git init
git remote add origin 添加仓库地址
git remote remove origin 删除仓库地址
增删改：git add . / commit / push

![img](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202303251430018.jpeg)





![image-20230617172656935](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202306171727540.png)

![image-20230617172935707](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202306171729849.png)



git comit：只会提交暂存区的文件，而不会提交工作区的文件，需要加上 -m表示提交文件的信息，否则在LINUX中会进入到vim中编辑







git reset：用于回退版本

![image-20230617174053324](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202306171740501.png)





git diff：查看各类差异

![image-20230617174509878](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202306171745050.png)





git rm：

![image-20230617174955568](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202306171749726.png)





2、.gitignore

把需要忽略的文件添加到.gitignore中，等到git add添加时，需要忽略的文件是不会被添加到暂存区的。

匹配规则：

![image-20230617180059793](https://raw.githubusercontent.com/BiAJiii/imgsBed/main/202306171800996.png)
